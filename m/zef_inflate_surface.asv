function nodes = zef_inflate_surfaces

inflation_strength = evalin('base','zef.inflation_strength');
reuna_t = evalin('base','zef.reuna_t');
reuna_p = evalin('base','zef.reuna_p');
reuna_type = evalin('base','zef.reuna_p');

if isequal(reuna_type{end,1},--1)
compartment_length = length(reuna_p); 
else
compartment_length = length(reuna_p);     
   

for compartment_counter = 1 : length(

[u_tri,~,u_tri_pos] = unique(tri);
im_ind = ismember(tetra, u_tri);
tetra_ind = find(sum(im_ind,2));
tetra = tetra(tetra_ind,:);

h_waitbar = waitbar(0, 'Inflating surface');

for i = 1 : length(u_tri)
   
p_ind = u_tri(i);
im_p_ind = ismember(tetra,p_ind);
tetra_p_ind = find(sum(im_p_ind,2));
p_tetra = tetra(tetra_p_ind,:);
p_tetra = unique(not(im_p_ind(tetra_p_ind,:)).*p_tetra);
p_tetra = setdiff(p_tetra,0);

if not(isempty(p_tetra))
    I = [];
    test_ind = 0; 
    p = nodes(p_ind,:);
    [~, sort_ind] = sort(sqrt(sum((nodes(p_tetra,:) - p).^2,2)));
    while isempty(I) && test_ind < length(p_tetra)
        test_ind = test_ind + 1;

p_min = p_tetra(sort_ind(test_ind));
vec_1_aux = nodes(p_min,:) - p;


vec_1 = vec_1_aux(ones(size(tri_ref,1),1),:);
d_vec = p(ones(size(tri_ref,1),1),:)  - nodes_tri_ref(tri_ref(:,1),:);
vec_2 = nodes_tri_ref(tri_ref(:,2),:) - nodes_tri_ref(tri_ref(:,1),:);
vec_3 = nodes_tri_ref(tri_ref(:,3),:) - nodes_tri_ref(tri_ref(:,1),:);

[lambda_1, lambda_2, lambda_3] = zef_3by3_solver(vec_1,vec_2,vec_3,d_vec);
I = find(lambda_1<0 & lambda_1 > -1 & lambda_2 >0 & lambda_2<1 & lambda_3>0 & lambda_3 <1); 

if not(isempty(I))
    
  lambda_1 = inflation_strength*min(abs(lambda_1(I)));
    nodes(p_ind,:) = p + lambda_1.*vec_1_aux;

end

 end
end

if mod(i,ceil(length(u_tri)/50))==0
waitbar(i/length(u_tri),h_waitbar,'Inflating surface');
end


end

close(h_waitbar);

end